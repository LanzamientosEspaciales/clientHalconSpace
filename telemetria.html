<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Órbita KSP - Kerbin</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #00ff00;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #telemetry {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00ff00;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            min-width: 300px;
            transition: transform 0.3s ease;
        }
        
        #telemetry.hidden {
            transform: translateX(-110%);
        }
        
        .telemetry-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }
        
        .data-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px;
            background: rgba(0, 50, 0, 0.3);
            border-radius: 5px;
            border-left: 3px solid #00ff00;
        }
        
        .label {
            color: #00ffaa;
            font-weight: bold;
        }
        
        .value {
            color: #ffffff;
            font-weight: bold;
            text-align: right;
        }
        
        .highlight {
            color: #ffff00;
            text-shadow: 0 0 5px rgba(255, 255, 0, 0.5);
        }
        
        .status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00ff00;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .toggle-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00ff00;
            padding: 10px 15px;
            border-radius: 10px;
            color: #00ff00;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .toggle-btn:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }
        
        #telemetry.hidden ~ .toggle-btn {
            left: 20px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        .status-online {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #00ffff;
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 30px;
            border: 2px solid #00ffff;
            border-radius: 10px;
        }
        
        .loading small {
            display: block;
            margin-top: 10px;
            font-size: 14px;
            color: #00ff00;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <button class="toggle-btn" id="toggleBtn">
            <span class="toggle-btn-icon">◀</span>
            <span class="toggle-btn-text">Ocultar Panel</span>
        </button>
        
        <div id="telemetry">
            <div class="telemetry-title">🚀 HALCON SPACE 🚀</div>
            <div class="data-row">
                <span class="label">Altitud:</span>
                <span class="value highlight" id="altitude">--- km</span>
            </div>
            <div class="data-row">
                <span class="label">Apogeo:</span>
                <span class="value" id="apogeo">--- km</span>
            </div>
            <div class="data-row">
                <span class="label">Perigeo:</span>
                <span class="value" id="perigeo">--- km</span>
            </div>
            <div class="data-row">
                <span class="label">Velocidad:</span>
                <span class="value" id="velocity">--- km/h</span>
            </div>
        </div>
        
        <div class="status">
            <span class="status-indicator status-online"></span>
            <span id="statusText">Conectando...</span>
        </div>
        
        <div class="loading" id="loading">Cargando visualización...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, doc, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        const firebaseConfig = {
            apiKey: "AIzaSyAiLw2zwfsjdMP-IlEoE5JugyFvmaQLFC0",
            authDomain: "halcon-space-348e7.firebaseapp.com",
            projectId: "halcon-space-348e7",
            storageBucket: "halcon-space-348e7.firebasestorage.app",
            messagingSenderId: "741724706453",
            appId: "1:741724706453:web:519531e63f2b923f952d9c",
            measurementId: "G-VG1Y2YMY4W"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Three.js setup
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);

        // Kerbin (Radio: 600,000 m)
        const kerbinRadius = 600;
        const kerbinGeometry = new THREE.SphereGeometry(kerbinRadius, 64, 64);
        const kerbinTexture = new THREE.TextureLoader().load('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZGVmcz48cmFkaWFsR3JhZGllbnQgaWQ9ImciPjxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiMzYTdhZmYiLz48c3RvcCBvZmZzZXQ9IjUwJSIgc3RvcC1jb2xvcj0iIzJhNmFkZiIvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3RvcC1jb2xvcj0iIzFhNWFjZiIvPjwvcmFkaWFsR3JhZGllbnQ+PC9kZWZzPjxyZWN0IHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiBmaWxsPSJ1cmwoI2cpIi8+PC9zdmc+');
        const kerbinMaterial = new THREE.MeshPhongMaterial({ 
            map: kerbinTexture,
            emissive: 0x1a5acf,
            emissiveIntensity: 0.2
        });
        const kerbin = new THREE.Mesh(kerbinGeometry, kerbinMaterial);
        scene.add(kerbin);

        // Atmósfera
        const atmosphereGeometry = new THREE.SphereGeometry(kerbinRadius * 1.12, 64, 64);
        const atmosphereMaterial = new THREE.MeshBasicMaterial({
            color: 0x4a9aff,
            transparent: true,
            opacity: 0.15,
            side: THREE.BackSide
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);

        // Iluminación
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(2000, 500, 1000);
        scene.add(sunLight);
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);

        // Cohete
        const rocketGeometry = new THREE.ConeGeometry(15, 50, 8);
        const rocketMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff3300,
            emissive: 0xff3300,
            emissiveIntensity: 0.5
        });
        const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
        scene.add(rocket);

        // Trail del cohete
        const trailPoints = [];
        const maxTrailPoints = 200;
        const trailGeometry = new THREE.BufferGeometry();
        const trailMaterial = new THREE.LineBasicMaterial({ 
            color: 0xff6600,
            transparent: true,
            opacity: 0.8
        });
        const trail = new THREE.Line(trailGeometry, trailMaterial);
        scene.add(trail);

        // Órbita elíptica
        let orbitLine = null;

        function createOrbit(perigeo, apogeo, inclination) {
            if (orbitLine) scene.remove(orbitLine);
            
            const a = (perigeo + apogeo) / 2000 + kerbinRadius; // Semi-eje mayor
            const c = (apogeo - perigeo) / 2000; // Distancia focal
            const b = Math.sqrt(a * a - c * c); // Semi-eje menor
            
            const points = [];
            const segments = 200;
            
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = a * Math.cos(angle) - c;
                const y = b * Math.sin(angle);
                const z = y * Math.sin(inclination * Math.PI / 180);
                const yRotated = y * Math.cos(inclination * Math.PI / 180);
                points.push(new THREE.Vector3(x, yRotated, z));
            }
            
            const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const orbitMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00,
                transparent: true,
                opacity: 0.6
            });
            orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
            scene.add(orbitLine);
        }

        // Marcadores de apogeo y perigeo
        let apogeoMarker = null;
        let perigeoMarker = null;

        function createMarkers(perigeo, apogeo, inclination) {
            if (apogeoMarker) scene.remove(apogeoMarker);
            if (perigeoMarker) scene.remove(perigeoMarker);
            
            const markerGeometry = new THREE.SphereGeometry(20, 16, 16);
            
            const apogeoMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            apogeoMarker = new THREE.Mesh(markerGeometry, apogeoMaterial);
            const apogeoDistance = apogeo / 1000 + kerbinRadius;
            apogeoMarker.position.set(-apogeoDistance, 0, 0);
            scene.add(apogeoMarker);
            
            const perigeoMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            perigeoMarker = new THREE.Mesh(markerGeometry, perigeoMaterial);
            const perigeoDistance = perigeo / 1000 + kerbinRadius;
            perigeoMarker.position.set(perigeoDistance, 0, 0);
            scene.add(perigeoMarker);
        }

        camera.position.set(2000, 1000, 2000);
        camera.lookAt(0, 0, 0);

        // Controles de cámara
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 700;
        controls.maxDistance = 8000;
        controls.enableZoom = true;
        controls.enableRotate = true;
        controls.enablePan = true;

        let telemetryData = {};
        let missionId = null;
        let telemetryActive = false;

        // Obtener ID de la misión desde la URL
        const urlParams = new URLSearchParams(window.location.search);
        missionId = urlParams.get('id');

        if (!missionId) {
            document.getElementById('statusText').textContent = 'SIN ID DE MISIÓN';
            document.getElementById('loading').innerHTML = '❌ No se especificó ID de misión<br><small>Usa ?id=[ID] en la URL</small>';
            console.error('No se proporcionó ID de misión en la URL');
        } else {
            // Verificar si la telemetría está activa para esta misión
            const missionRef = doc(db, 'lanzamientos', missionId);
            onSnapshot(missionRef, (docSnap) => {
                if (docSnap.exists()) {
                    const missionData = docSnap.data();
                    telemetryActive = missionData.telemetria_on === true;
                    
                    if (!telemetryActive) {
                        document.getElementById('statusText').textContent = 'TELEMETRÍA DESACTIVADA';
                        document.getElementById('loading').innerHTML = '⚠️ Telemetría desactivada para esta misión<br><small>' + (missionData.nombre || missionId) + '</small>';
                    } else {
                        document.getElementById('loading').style.display = 'none';
                        // Iniciar escucha de telemetría
                        startTelemetryListener();
                    }
                } else {
                    document.getElementById('statusText').textContent = 'MISIÓN NO ENCONTRADA';
                    document.getElementById('loading').innerHTML = '❌ Misión no encontrada<br><small>ID: ' + missionId + '</small>';
                }
            });
        }

        function startTelemetryListener() {
            // Escuchar datos de Firestore
            const docRef = doc(db, 'telemetria', 'estado_actual');
            onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists() && telemetryActive) {
                    const data = docSnap.data();
                    telemetryData = data;
                    updateTelemetryDisplay(data);
                    updateOrbit(data);
                    updateRocketPosition();
                    document.getElementById('statusText').textContent = 'CONECTADO';
                } else if (!telemetryActive) {
                    document.getElementById('statusText').textContent = 'TELEMETRÍA DESACTIVADA';
                } else {
                    console.log("No existe el documento!");
                    document.getElementById('statusText').textContent = 'SIN DATOS';
                }
            }, (error) => {
                console.error("Error al escuchar datos:", error);
                document.getElementById('statusText').textContent = 'ERROR CONEXIÓN';
            });
        }

        function updateTelemetryDisplay(data) {
            document.getElementById('altitude').textContent = 
                ((data.altitude_m || 0) / 1000).toLocaleString('es-ES', {minimumFractionDigits: 1, maximumFractionDigits: 1}) + ' km';
            document.getElementById('apogeo').textContent = 
                ((data.apogeo || 0) / 1000).toLocaleString('es-ES', {minimumFractionDigits: 1, maximumFractionDigits: 1}) + ' km';
            document.getElementById('perigeo').textContent = 
                ((data.perigeo || 0) / 1000).toLocaleString('es-ES', {minimumFractionDigits: 1, maximumFractionDigits: 1}) + ' km';
            document.getElementById('velocity').textContent = 
                Math.round(data.velocity_kmh || 0).toLocaleString('es-ES') + ' km/h';
        }

        function updateOrbit(data) {
            if (data.perigeo && data.apogeo) {
                createOrbit(data.perigeo, data.apogeo, data.inclination || 0);
                createMarkers(data.perigeo, data.apogeo, data.inclination || 0);
            }
        }

        function updateRocketPosition() {
            if (telemetryData.altitude_m && telemetryData.perigeo && telemetryData.apogeo) {
                const perigeo = telemetryData.perigeo / 1000;
                const apogeo = telemetryData.apogeo / 1000;
                const altitude = telemetryData.altitude_m / 1000;
                const inclination = (telemetryData.inclination || 0) * Math.PI / 180;
                
                // Calcular parámetros orbitales
                const a = (perigeo + apogeo) / 2 + kerbinRadius; // Semi-eje mayor
                const c = (apogeo - perigeo) / 2; // Distancia focal
                const b = Math.sqrt(a * a - c * c); // Semi-eje menor
                
                // Calcular distancia actual desde el centro de Kerbin
                const r = altitude + kerbinRadius;
                
                // Resolver el ángulo en la elipse para la distancia actual
                // Usando la ecuación: r = a(1-e²)/(1+e*cos(θ))
                const e = c / a; // Excentricidad
                const cosTheta = (a * (1 - e * e) / r - 1) / e;
                const theta = Math.acos(Math.max(-1, Math.min(1, cosTheta)));
                
                // Calcular posición en la órbita
                const x = (a * Math.cos(theta) - c);
                const y = b * Math.sin(theta);
                
                rocket.position.x = x;
                rocket.position.y = y * Math.cos(inclination);
                rocket.position.z = y * Math.sin(inclination);

                // Orientar el cohete tangente a la órbita
                const nextTheta = theta + 0.01;
                const nextX = (a * Math.cos(nextTheta) - c);
                const nextY = b * Math.sin(nextTheta);
                const nextPos = new THREE.Vector3(
                    nextX,
                    nextY * Math.cos(inclination),
                    nextY * Math.sin(inclination)
                );
                rocket.lookAt(nextPos);

                // Actualizar trail
                trailPoints.push(rocket.position.clone());
                if (trailPoints.length > maxTrailPoints) {
                    trailPoints.shift();
                }
                trailGeometry.setFromPoints(trailPoints);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            kerbin.rotation.y += 0.001;
            atmosphere.rotation.y += 0.0005;

            controls.update();

            renderer.render(scene, camera);
        }

        animate();

        // Toggle panel telemetría
        const toggleBtn = document.getElementById('toggleBtn');
        const toggleBtnText = toggleBtn.querySelector('.toggle-btn-text');
        const telemetryPanel = document.getElementById('telemetry');
        let isHidden = false;

        toggleBtn.addEventListener('click', () => {
            isHidden = !isHidden;
            if (isHidden) {
                telemetryPanel.classList.add('hidden');
                toggleBtnText.textContent = 'Mostrar Panel';
            } else {
                telemetryPanel.classList.remove('hidden');
                toggleBtnText.textContent = 'Ocultar Panel';
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>